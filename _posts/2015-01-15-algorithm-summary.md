---
layout: default
title: Algorithm Design - A Summary
categories: algorithm-design
---

- 知识点：
	* 某些生成树，BFS是找不到的
	* $$log(n)$$ is $$O(n^d)$$ for $$d > 0$$.
	* 二部图不能含有奇数回路。




	* 强联通分量：有向图中，任意两个顶点可达。
	* 找到强联通分量：tarjan或者两遍DFS
	* 无向图找环：1. 二染色DFS或者BFS
	* 有向图找环：1. 拓扑排序 2. 强联通分量 3. 三染色DFS
	* 半联通：两个顶点至少有一个方向可达。
	* 弱联通：不考虑方向，两个顶点可达。
	* 贪心最短路Dijstra：扩展集合的思想。当存在负边时，不能使用。
	* 贪心最小生成树Prim，Kruskal
	* 若干贪心证明方法：归纳（贪心算法一定保持领先），交换法（找两个解的不同点或者逆序对），找贪心算法所包含的最优结构（参考教室排课问题）
	* 割：一个环在一个割中的边树一定是偶数
	* 最小生成树两个性质：1. 任何一个割中最小的边一定在MST里。2. 任何一个环中最大的边一定不再MST里。
	* 贪心最小生成树Kruskal：1. 存在一种排列方式，构造出任意一颗MST 
	* 归并排序是稳定的
	* 没有满足三个条件的排序算法：1. 复杂度$$nlog(n)$$， 2. 稳定 3. 不占用额外空间
	* 保证算法复杂度的快排，三分，中间相等。
	* 找较好的pivot，每五个数找中位数，中位数的中位数，保证在中间范围（不是中位数）。
	* 主定理：1. $$f(n)$$比$$n^{k}$$小，则$$O(n^k)$$ 2. $$f(n)$$和$$O(n^klog^p(n))$$同阶，则$$O(n^klog^{p+1}(n))$$ 3. $$f(n)$$高阶，则$$O(f(n))$$
	* 复杂度比较的技巧：取log，但是反过来不行
	* bellman-ford：Yen的改进，用两次遍历，一次正向，一次逆向
	* 如果存在负环，则bellman-ford算法不可用，但是可以检测
	* 三种求网络流的方式
		* 二分查找容量
		* BFS
		* Blocking Flow

- 证明：
	- stable matching
		* GS算法中每个人都会被匹配
		* GS算法中没有不稳定匹配
		* GS算法是man-optimal
	- graph
		* DAG是半联通的等价于拓扑排序是唯一的：拓扑排序唯一等价于任意两点可达，DAG&&半联通保证不存在回路
		* 对于图G，深搜广搜得到相同的树T，证明T=G：同层或者不同层
	- greedy
		* 无权不可滑动区间选择问题中，最早结束时间优先算法是最优的：假设存在另一个解。。
		* 无权不可滑动区间分配问题（教室排课问题）中，最早开始时间优先算法是最优的：在分配最后一个教室时，没有其他算法能够给出更优解
		* 无权可滑动区间最小延迟问题中，最早结束时间优先算法是最优的：对于任何逆序对，交换都能使得延迟减小
		* 带权排队代价问题：对于任何逆序对，交换都能使得代价减小
		* 带权可抢占排队代价问题：同上
		* 卡车装货问题：归纳证明贪心不可能更差
		* 敏感进程覆盖作业题：存在另一个解，然后交换证明贪心不会更差
		* 无权重带最晚结束时间问题：按最早结束时间排序，替换。
		
		* Dijstra算法保证找到最优解：反证。。
		* 边长不同的图中存在唯一的MST：反证法＝》构造环＝》寻找矛盾
		* 使得图中任意两点间流量最大的图是一颗树：反正法＝》构造环＝》寻找矛盾
		* Kruskal保证聚类算法找到类间距离尽量大：假设两个点在贪心算法中是在同一聚类中，而在最优解中在两个聚类内。。
		* 如果一个割有多条最小边，则他们都至少出现在某一棵MST中：不知道
		* 如果某条边不是最小边，那也不一定不出现在MST中：反例
		* 如果某条边不是环上最重的，那也不一定出现在MST中：反例
		* 如果某条边不是任意一个环上最重的，那一定出现在MST中：若边不在MST中，则存在一个条路径连接u,v，路径上的边全部比该边短。
		* 如果某条边不是任意一个割上最重的，那一定不在MST中：随便找一个割。。
	- bellman-ford
		* 根据successor找到的路径不一定等于$$d(v)$$
		* 如果successor中存在回路，这一定存在负环：用多条不等式证明。
		* 第i次迭代的时候，$$d(v)$$可能用了比$$i$$条边更多的边。这是由于迭代顺序导致的。但是，当前$$d(v)$$至少要比用$$i$$条边组成的最短路径要短。
	- network flow
		* 三个等价命题
			* 1.存在一个割,它的容量与当前流量相等。 
			* 2.该流就是最大流。因为任意流的流量不大于任意割的容量,不可能再找到更大流。 
			* 3.残留网络已经找不到增广路径。
		* 完美匹配
			* 一个图存在完美匹配，如果对于任何一个集合`S`，$$\|N(S)\|$$大于$$\|S\|$$.
			* K-regular匹配。流拆分＋整数定理
		* 在disjoint path问题中，讲一条边拆分成两条有向边，证明对于任意一条路径，不可能同时存在两个方向的流量
		* 在多源多汇网络流中，如果存在一个割（这里的割不一定把源点和汇点分到两边）他需要输出的流量大于割的容量，则不存在可行解。
	
	- NPC问题：
		* 带权可上下滑动的区间规划问题，带权仅有最晚结束时间和带权仅有最早开始时间的区间规划问题：用背包问题规约可上下滑动的例子。
		* 独立集问题：3-SAT问题规约
		* 顶点覆盖问题：用独立集规约，等价
		* 区间覆盖问题：用顶点覆盖规约
		* 最长简单路径：用哈密尔顿回路规约
		* 最短简单路径：用最长简单路径规约
		* 无向哈密尔顿回路：用有向哈密尔顿规约
		* TSP问题：用哈密尔顿回路规约
		* 双重标准最短路判定问题：用子集合问题规约
		* 最大团问题：用补图的独立集问题规约
		* 子图同构问题：用最大团问题规约或者哈密尔顿问题规约
		* 子集划分问题：用子集合问题规约
		* 子集合问题：用子集划分问题规约
		* 背包问题：用子集合问题规约
		* k着色问题：用3着色问题规约
		* 最小化类内距离聚类问题：用k着色问题规约
	

- 问题集合
	- 二部图
		- 蝴蝶分类问题
		- 航班调度问题
	- 贪心问题［大部分都归类为证明题］：
		* Prim
		* Dijstra
		* Kruskal
	- 分治问题：
		* 二维最近点对问题
		* 绝对众数，迭代查找每个区间的绝对众数；$$O(n)$$的算法需要最后检验一次，因为不是充分条件
		* 逆序数，超逆序数
		* 双排序数组找k大数
		* 水瓶匹配
		* 矩阵找极小值问题
		* 矩阵中每一行和每一列都是排序的，问是否存在某一个数
	- DP问题：
		* 背包问题，0-1背包问题（反向循环），完全背包问题（正向循环），扩展：限制容量
		* 编辑距离（分治优化）
		* 最长递增子序列
		* k段最小平方误差线性回归问题
		* 带权重的不可滑动区间调度问题
		* 带最晚结束时间的可滑动问题：三种dp方式，注意保留deadline信息。
		* RNA匹配问题，遍历中间节点即可。
		* 数组合并问题
	- 最短路问题：
		* Distance Vector Protocol (routing by rumor)：bellman-ford
		* Path Vector Protocol：Dijstra
		* Floyd
		* 负环检测：
			* bellman-ford时纪录第n次仍然被更新的点，从这个点开始反向找环。
			* SPFA纪录每个点的入队列次数，即更新次数。不过SPFA好像不是每次更新入一次队列。
			* Floyd查看$$d(i,i)$$是否小于0，$$d(i,j)-len(i,j)$$是否小于0
	- 网络流问题：
		* 有向disjoin-path问题中，设置边容量为1，然后跑最大流
		* 无向disjoin-path问题中，将一条边拆分成两个方向的容量为1的边，同有向。
		* 多源多汇网络流，限流网络：减掉下界，更新两边节点的流量。然后添加超源点和超汇点，构建基本流网络，跑最大流算法。
		* survey-design：一个源点＋一个汇点＋每个其他结点代表一个人或者产品，边的流量的上下界代表限制，因为带了上下届，所以需要多源多汇模型，又因为需要最大流量，将源点和汇点用一条无上界的边连了起来
		* 航班调度问题：拆点加容量限制，该题求最小流量，所以不能简单加上一个汇点到原点的无限流量边［也可以用二分图解决］
		* 图像分割问题：首先将问题转化成最小割问题，等同于求最大流，构造三层图结构
		* 项目选择问题：首先将问题转化为最小割问题，正收益项目连源点，负收益项目连汇点
		* baseball elimination：对于每一个队伍，判断一次最大流是否充满源点出边。到汇点的边表示某队最多还能赢几次，如果这些边都被填满的时候还存在某些出边没有被分配的话，就说明这支队一定会被某支队淘汰
